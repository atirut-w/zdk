#include "asm_printer.hpp"
#include "zir/instruction.hpp"
#include <string>

using namespace std;
using namespace ZIR;

void AsmPrinter::generate_prologue() {
  int offset = 0;
  for (auto &instruction : ctx.current_function->instructions) {
    if (instruction.result && holds_alternative<string>(*instruction.result)) {
      ctx.offsets[get<string>(*instruction.result)] = offset;
      offset -= 2;
    }
  }
}

string AsmPrinter::get_ix(int offset) {
  if (offset <= 0) {
    return "(ix-" + to_string(-offset) + ")";
  } else {
    return "(ix+" + to_string(offset) + ")";
  }
}

void AsmPrinter::load(const Value &value) {
  if (holds_alternative<string>(value)) {
    auto name = get<string>(value);
    int offset = ctx.offsets[name];
    
    os << "\tld l, " << get_ix(offset) << "\n";
    os << "\tld h, " << get_ix(offset + 1) << "\n";
  } else if (holds_alternative<int>(value)) {
    auto immediate = get<int>(value);
    os << "\tld hl, " << immediate << "\n";
  }
}

void AsmPrinter::store(const Value &value) {
  if (holds_alternative<string>(value)) {
    auto name = get<string>(value);
    int offset = ctx.offsets[name];
    
    os << "\tld " << get_ix(offset) << ", l\n";
    os << "\tld " << get_ix(offset + 1) << ", h\n";
  }
}

void AsmPrinter::print() {
  os << "\t; Generated by ZDK C Compiler\n\n";
  
  for (auto &function : module.functions) {
    ctx = {};
    ctx.current_function = &function;
    generate_prologue();

    os << "\t.global " << function.name << "\n";
    os << function.name << ":\n";

    for (auto &instruction : function.instructions) {
      switch (instruction.operation) {
      case Instruction::RETURN:
        if (!ctx.offsets.empty()) {
          os << "\tld sp, ix\n";
          os << "\tpop ix\n";
        }
        os << "\tret\n";
        break;
      case Instruction::COMPLEMENT:
      case Instruction::NEGATE:
        load(instruction.operands[0]);

        if (instruction.operation == Instruction::COMPLEMENT) {
          os << "\tld a, h\n";
          os << "\tcpl\n";
          os << "\tld h, a\n";
          os << "\tld a, l\n";
          os << "\tcpl\n";
          os << "\tld l, a\n";
        } else if (instruction.operation == Instruction::NEGATE) {
          os << "\txor a\n";
          os << "\tsub l\n";
          os << "\tld l, a\n";
          os << "\tsbc a, a\n";
          os << "\tsub h\n";
          os << "\tld h, a\n";
        }

        if (instruction.result) {
          store(*instruction.result);
        }
        break;
      }
    }
  }
}
