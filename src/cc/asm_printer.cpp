#include "asm_printer.hpp"
#include <cstdlib>
#include <iostream>
#include <llvm/IR/Constants.h>
#include <llvm/IR/Instruction.h>
#include <llvm/IR/Instructions.h>
#include <llvm/Support/TypeSize.h>
#include <string>

using namespace std;
using namespace llvm;

void AsmPrinter::generate_prologue() {
  int offset = 0;
  int blocknum = 0;
  for (auto &block : *current_function) {
    blocknums[&block] = blocknum++;
    for (auto &instruction : block) {
      if (auto alloca = dyn_cast<AllocaInst>(&instruction)) {
        offsets[&instruction] = offset;
        Type *type = alloca->getAllocatedType();
        TypeSize size = module.getDataLayout().getTypeAllocSize(type);
        offset -= size;
      } else if (!instruction.getType()->isVoidTy()) {
        offsets[&instruction] = offset;
        Type *type = instruction.getType();
        TypeSize size = module.getDataLayout().getTypeAllocSize(type);
        offset -= size;
      }
    }
  }

  if (offset < 0) {
    os << "\tpush ix\n";
    os << "\tld ix, " << offset << "\n";
    os << "\tadd ix, sp\n";
    os << "\tld sp, ix\n";
  }
}

string AsmPrinter::get_ix(int base, int offset) {
  if (base <= 0) {
    return "(ix-" + to_string(abs(base) + offset) + ")";
  } else {
    return "(ix+" + to_string(base + offset) + ")";
  }
}

void AsmPrinter::load_value(const Value *value) {
  if (auto *constant = dyn_cast<ConstantInt>(value)) {
    os << "\tld hl, " << constant->getSExtValue() << "\n";
  } else {
    int offset = offsets[value];

    os << "\tld l, " << get_ix(offset) << "\n";
    os << "\tld h, " << get_ix(offset, 1) << "\n";
  }
}

void AsmPrinter::store_value(const Value *value) {
  int offset = offsets[value];
  os << "\tld " << get_ix(offset) << ", l\n";
  os << "\tld " << get_ix(offset, 1) << ", h\n";
}

void AsmPrinter::print() {
  os << "\t; Generated by ZDK C Compiler\n\n";

  for (auto &function : module) {
    string name = function.getName().str();
    current_function = &function;

    os << "\t.global " << name << "\n";
    os << name << ":\n";
    generate_prologue();

    for (auto &block : function) {
      current_block = &block;
      os << blocknums[&block] << ":\n";
      for (auto &instruction : block) {
        print_instruction(&instruction);
      }
    }
  }
}

void AsmPrinter::print_instruction(const Instruction *instruction) {
  switch (instruction->getOpcode()) {
  default:
    outs() << *instruction << "\n";
    // throw runtime_error("unhandled instruction");
    cerr << "unhandled opcode: " << instruction->getOpcode() << "\n";
    break;

  // Terminator instructions :robot:
  case Instruction::Ret:
    print_return(cast<ReturnInst>(instruction));
    break;
  case Instruction::Br:
    print_br(cast<BranchInst>(instruction));
    break;

  // Binary instructions
  case Instruction::Add:
    print_add(cast<BinaryOperator>(instruction));
    break;
  case Instruction::Sub:
    print_sub(cast<BinaryOperator>(instruction));
    break;
  case Instruction::Xor:
    print_xor(cast<BinaryOperator>(instruction));
    break;

  // Memory instructions
  case Instruction::Alloca:
    break;
  case Instruction::Load:
    print_load(cast<LoadInst>(instruction));
    break;
  case Instruction::Store:
    print_store(cast<StoreInst>(instruction));
    break;
  }
}

void AsmPrinter::print_return(const ReturnInst *ret) {
  if (auto *value = ret->getReturnValue()) {
    load_value(value);
  }
  if (!offsets.empty()) {
    os << "\tld sp, ix\n";
    os << "\tpop ix\n";
  }
  os << "\tret\n";
}

void AsmPrinter::print_br(const BranchInst *br) {
  if (br->isConditional()) {
    // TODO: Implement
  } else {
    os << "\tjr " << blocknums[br->getSuccessor(0)];
    if (blocknums[br->getSuccessor(0)] < blocknums[current_block]) {
      os << "b";
    } else {
      os << "f";
    }
    os << "\n";
  }
}

void AsmPrinter::print_add(const BinaryOperator *add) {
  load_value(add->getOperand(1));
  os << "\tpush hl\n";
  os << "\tpop de\n";
  load_value(add->getOperand(0));
  os << "\tadd hl, de\n";
  store_value(add);
}

void AsmPrinter::print_sub(const BinaryOperator *sub) {
  load_value(sub->getOperand(1));
  os << "\tpush hl\n";
  os << "\tpop de\n";
  load_value(sub->getOperand(0));
  os << "\txor a\n";
  os << "\tsbc hl, de\n";
  store_value(sub);
}

void AsmPrinter::print_xor(const BinaryOperator *xor_) {
  load_value(xor_->getOperand(1));
  os << "\tpush hl\n";
  os << "\tpop de\n";
  load_value(xor_->getOperand(0));
  os << "\tld a, l\n";
  os << "\txor e\n";
  os << "\tld l, a\n";
  os << "\tld a, h\n";
  os << "\txor d\n";
  os << "\tld h, a\n";
  store_value(xor_);
}

void AsmPrinter::print_load(const LoadInst *load) {
  load_value(load->getPointerOperand());
  store_value(load);
}

void AsmPrinter::print_store(const StoreInst *store) {
  const Value *value = store->getValueOperand();

  if (auto *constant = dyn_cast<ConstantInt>(value)) {
    os << "\tld " << get_ix(offsets[store->getPointerOperand()]) << ", " << (constant->getSExtValue() & 0xff) << "\n";
    os << "\tld " << get_ix(offsets[store->getPointerOperand()], 1) << ", " << (constant->getSExtValue() >> 8) << "\n";
  } else {
    load_value(value);
    store_value(store->getPointerOperand());
  }
}
