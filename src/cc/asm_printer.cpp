#include "asm_printer.hpp"
#include "register_allocator.hpp"
#include <cstdlib>
#include <iostream>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/Instruction.h>
#include <llvm/IR/Instructions.h>
#include <llvm/Support/TypeSize.h>
#include <string>

using namespace std;
using namespace llvm;

map<int, string> register_names = {
    {RegisterAllocator::R8_A, "a"},        {RegisterAllocator::R8_B, "b"},        {RegisterAllocator::R8_C, "c"},    {RegisterAllocator::R8_D, "d"},
    {RegisterAllocator::R8_E, "e"},        {RegisterAllocator::R8_H, "h"},        {RegisterAllocator::R8_L, "l"},

    {RegisterAllocator::R16_BC, "bc"},     {RegisterAllocator::R16_DE, "de"},     {RegisterAllocator::R16_HL, "hl"},

    {RegisterAllocator::R32_BCDE, "bcde"}, {RegisterAllocator::R32_DEHL, "dehl"},
};

void AsmPrinter::generate_prologue() {
  int offset = 0;
  int blocknum = 0;
  for (auto &block : *current_function) {
    blocknums[&block] = blocknum++;
    for (auto &instruction : block) {
      if (auto alloca = dyn_cast<AllocaInst>(&instruction)) {
        offsets[&instruction] = offset;
        Type *type = alloca->getAllocatedType();
        TypeSize size = module.getDataLayout().getTypeAllocSize(type);
        offset -= size;
      } else if (!instruction.getType()->isVoidTy()) {
        offsets[&instruction] = offset;
        Type *type = instruction.getType();
        TypeSize size = module.getDataLayout().getTypeAllocSize(type);
        offset -= size;
      }
    }
  }

  if (offset < 0) {
    os << "\tpush ix\n";
    os << "\tld ix, 0\n";
    os << "\tadd ix, sp\n";
    os << "\tld sp, ix\n";

    os << "\tld hl, " << offset << "\n";
    os << "\tadd hl, sp\n";
    os << "\tld sp, hl\n";
  }
}

string AsmPrinter::get_ix(int base, int offset) {
  if (base <= 0) {
    return "(ix-" + to_string(abs(base) + offset) + ")";
  } else {
    return "(ix+" + to_string(base + offset) + ")";
  }
}

string AsmPrinter::get_label(const BasicBlock *block) {
  string label = to_string(blocknums[block]);
  if (blocknums[block] < blocknums[current_block]) {
    label += "b";
  } else {
    label += "f";
  }
  return label;
}

void AsmPrinter::check_phi(const BasicBlock *block) {
  for (auto &instruction : *block) {
    if (auto *phi = dyn_cast<PHINode>(&instruction)) {
      for (unsigned i = 0; i < phi->getNumIncomingValues(); i++) {
        BasicBlock *incoming_block = phi->getIncomingBlock(i);
        Value *value = phi->getIncomingValue(i);

        if (incoming_block == current_block) {
          // load_value(value);
          // store_value(phi);
        }
      }
    }
  }
}

void AsmPrinter::load_value(const Value *value, int reg) {
  string reg_name = register_names[reg];

  cout << "loading value into " << reg_name << "\n";
  if (auto *constant = dyn_cast<ConstantInt>(value)) {
    Type *type = value->getType();
    TypeSize size = module.getDataLayout().getTypeAllocSize(type);

    if (size < 4) {
      os << "\tld " << reg_name << ", " << constant->getSExtValue() << "\n";
    } else {
      os << "\tld " << reg_name.substr(2, 2) << ", " << (constant->getSExtValue() & 0xff) << "\n";
      os << "\tld " << reg_name.substr(0, 2) << ", " << (constant->getSExtValue() >> 8) << "\n";
    }
  } else if (auto *alloca = dyn_cast<AllocaInst>(value)) {
    int offset = offsets[value];
    Type *type = alloca->getAllocatedType();
    TypeSize size = module.getDataLayout().getTypeAllocSize(type);

    for (int i = 0; i < size; i++) {
      os << "\tld " << reg_name[size - i - 1] << ", " << get_ix(offset, i) << "\n";
    }
  }
}

void AsmPrinter::store_value(const Value *value) {
  
}

void AsmPrinter::print() {
  os << "\t; Generated by ZDK C Compiler\n\n";

  for (auto &function : module) {
    string name = function.getName().str();
    current_function = &function;

    RegisterAllocator allocator(module);
    allocator.run(function);
    allocation = allocator.allocation;

    os << "\t.global " << name << "\n";
    os << name << ":\n";
    generate_prologue();

    for (auto &block : function) {
      current_block = &block;
      os << blocknums[&block] << ":\n";
      for (auto &instruction : block) {
        print_instruction(&instruction);
      }
    }
  }
}

void AsmPrinter::print_instruction(const Instruction *instruction) {
  switch (instruction->getOpcode()) {
  default:
    outs() << *instruction << "\n";
    // throw runtime_error("unhandled instruction");
    cerr << "unhandled opcode: " << instruction->getOpcode() << "\n";
    break;

  // Terminator instructions :robot:
  case Instruction::Ret:
    print_return(cast<ReturnInst>(instruction));
    break;
  case Instruction::Br:
    print_br(cast<BranchInst>(instruction));
    break;

  // Binary instructions
  case Instruction::Add:
    print_add(cast<BinaryOperator>(instruction));
    break;
  case Instruction::Sub:
    print_sub(cast<BinaryOperator>(instruction));
    break;
  case Instruction::Xor:
    print_xor(cast<BinaryOperator>(instruction));
    break;

  // Memory instructions
  case Instruction::Alloca:
    break;
  case Instruction::Load:
    print_load(cast<LoadInst>(instruction));
    break;
  case Instruction::Store:
    print_store(cast<StoreInst>(instruction));
    break;

  // Cast instructions
  case Instruction::ZExt:
    print_zext(cast<ZExtInst>(instruction));
    break;

  // Other instructions
  case Instruction::ICmp:
    print_icmp(cast<ICmpInst>(instruction));
    break;
  case Instruction::PHI:
    break;
  }
}

void AsmPrinter::print_return(const ReturnInst *ret) {
  if (auto *value = ret->getReturnValue()) {
    load_value(value, allocation[value]);
  }
  if (!offsets.empty()) {
    os << "\tld sp, ix\n";
    os << "\tpop ix\n";
  }
  os << "\tret\n";
}

void AsmPrinter::print_br(const BranchInst *br) {
  if (br->isConditional()) {
    BasicBlock *true_block = br->getSuccessor(0);
    BasicBlock *false_block = br->getSuccessor(1);

    // load_value(br->getCondition());
    os << "\tld a, l\n";
    os << "\tand h\n";

    check_phi(true_block);
    os << "\tjr nz, " << get_label(true_block) << "\n";
    check_phi(false_block);
    os << "\tjr " << get_label(false_block) << "\n";
  } else {
    check_phi(br->getSuccessor(0));
    os << "\tjr " << get_label(br->getSuccessor(0)) << "\n";
  }
}

void AsmPrinter::print_add(const BinaryOperator *add) {
  Value *lhs = add->getOperand(0);
  Value *rhs = add->getOperand(1);
  load_value(lhs, allocation[lhs]);
  load_value(rhs, allocation[rhs]);
  os << "\tadd hl, " << register_names[allocation[rhs]] << "\n";
  store_value(add);
}

void AsmPrinter::print_sub(const BinaryOperator *sub) {
  Value *lhs = sub->getOperand(0);
  Value *rhs = sub->getOperand(1);
  load_value(lhs, allocation[lhs]);
  load_value(rhs, allocation[rhs]);
  os << "\txor a\n";
  os << "\tsbc hl, " << register_names[allocation[rhs]] << "\n";
  store_value(sub);
}

void AsmPrinter::print_xor(const BinaryOperator *xor_) {
  // load_value(xor_->getOperand(0));
  // load_value(xor_->getOperand(1), "de");
  os << "\tld a, l\n";
  os << "\txor e\n";
  os << "\tld l, a\n";
  os << "\tld a, h\n";
  os << "\txor d\n";
  os << "\tld h, a\n";
  store_value(xor_);
}

void AsmPrinter::print_load(const LoadInst *load) {
  load_value(load->getPointerOperand(), allocation[load]);
}

void AsmPrinter::print_store(const StoreInst *store) {
  const Value *value = store->getValueOperand();

  if (auto *constant = dyn_cast<ConstantInt>(value)) {
    os << "\tld " << get_ix(offsets[store->getPointerOperand()]) << ", " << (constant->getSExtValue() & 0xff) << "\n";
    os << "\tld " << get_ix(offsets[store->getPointerOperand()], 1) << ", " << (constant->getSExtValue() >> 8) << "\n";
  } else {
    // load_value(value);
    store_value(store->getPointerOperand());
  }
}

void AsmPrinter::print_zext(const ZExtInst *zext) {
  // load_value(zext->getOperand(0));
  os << "\tld h, 0\n";
  store_value(zext);
}

void AsmPrinter::print_icmp(const ICmpInst *icmp) {
  // load_value(icmp->getOperand(0));
  // load_value(icmp->getOperand(1), "de");

  // Set flags
  os << "\txor a\n";
  os << "\tsbc hl, de\n";
  // Obtain flags
  os << "\tpush af\n";
  os << "\tpop hl\n";

  switch (icmp->getPredicate()) {
  default:
    cerr << "unhandled icmp predicate: " << icmp->getPredicate() << "\n";
    break;
  case ICmpInst::ICMP_EQ:
    os << "\tld a, l\n";
    os << "\tand " << (1 << 6) << "\n";
    os << "\tld l, a\n";
    break;
  case ICmpInst::ICMP_NE:
    os << "\tld a, l\n";
    os << "\tand " << (1 << 6) << "\n";
    os << "\txor " << (1 << 6) << "\n";
    os << "\tld l, a\n";
    break;
  }

  store_value(icmp);
}
