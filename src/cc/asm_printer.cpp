#include "asm_printer.hpp"
#include <cstdlib>
#include <llvm/IR/Constants.h>
#include <llvm/IR/Instruction.h>
#include <llvm/IR/Instructions.h>
#include <llvm/Support/TypeSize.h>
#include <string>

using namespace std;
using namespace llvm;

void AsmPrinter::generate_prologue() {
  int offset = 0;
  for (auto &block : *current_function) {
    for (auto &instruction : block) {
      if (auto alloca = dyn_cast<AllocaInst>(&instruction)) {
        offsets[&instruction] = offset;
        Type *type = alloca->getAllocatedType();
        TypeSize size = module.getDataLayout().getTypeAllocSize(type);
        offset += size;
      } else if (!instruction.getType()->isVoidTy()) {
        offsets[&instruction] = offset;
        Type *type = instruction.getType();
        TypeSize size = module.getDataLayout().getTypeAllocSize(type);
        offset -= size;
      }
    }
  }

  if (offset < 0) {
    os << "\tpush ix\n";
    os << "\tld ix, " << offset << "\n";
    os << "\tadd ix, sp\n";
    os << "\tld sp, ix\n";
  }
}

string AsmPrinter::get_ix(int base, int offset) {
  if (base <= 0) {
    return "(ix-" + to_string(abs(base) + offset) + ")";
  } else {
    return "(ix+" + to_string(base + offset) + ")";
  }
}

void AsmPrinter::load(const Value *value) {
  if (auto *constant = dyn_cast<ConstantInt>(value)) {
    os << "\tld hl, " << constant->getSExtValue() << "\n";
  } else {
    int offset = offsets[value];
    
    os << "\tld l, " << get_ix(offset) << "\n";
    os << "\tld h, " << get_ix(offset, 1) << "\n";
  }
}

void AsmPrinter::store(const Value *value) {
  int offset = offsets[value];
  os << "\tld " << get_ix(offset) << ", l\n";
  os << "\tld " << get_ix(offset, 1) << ", h\n";
}

void AsmPrinter::print() {
  os << "\t; Generated by ZDK C Compiler\n\n";
  
  for (auto &function : module) {
    string name = function.getName().str();
    current_function = &function;

    os << "\t.global " << name << "\n";
    os << name << ":\n";
    generate_prologue();

    for (auto &block : function) {
      for (auto &instruction : block) {
        print_instruction(&instruction);
      }
    }
  }
}

void AsmPrinter::print_instruction(const Instruction *instruction) {
  switch (instruction->getOpcode()) {
  default:
    outs() << *instruction << "\n";
    throw runtime_error("unhandled instruction");

  // No-op
  case Instruction::Alloca:
    break;

  case Instruction::Ret:
    if (auto *value = dyn_cast<ReturnInst>(instruction)->getReturnValue()) {
      load(value);
    }
    if (!offsets.empty()) {
      os << "\tld sp, ix\n";
      os << "\tpop ix\n";
    }
    os << "\tret\n";
    break;
  }
}
