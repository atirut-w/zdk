#include "asm_printer.hpp"
#include <cstdlib>
#include <iostream>
#include <llvm/IR/Constants.h>
#include <llvm/IR/Instruction.h>
#include <llvm/IR/Instructions.h>
#include <llvm/Support/TypeSize.h>
#include <string>

using namespace std;
using namespace llvm;

void AsmPrinter::generate_prologue() {
  int offset = 0;
  int blocknum = 0;
  for (auto &block : *current_function) {
    blocknums[&block] = blocknum++;
    for (auto &instruction : block) {
      if (auto alloca = dyn_cast<AllocaInst>(&instruction)) {
        offsets[&instruction] = offset;
        Type *type = alloca->getAllocatedType();
        TypeSize size = module.getDataLayout().getTypeAllocSize(type);
        offset -= size;
      } else if (!instruction.getType()->isVoidTy()) {
        offsets[&instruction] = offset;
        Type *type = instruction.getType();
        TypeSize size = module.getDataLayout().getTypeAllocSize(type);
        offset -= size;
      }
    }
  }

  if (offset < 0) {
    os << "\tpush ix\n";
    os << "\tld ix, 0\n";
    os << "\tadd ix, sp\n";
    os << "\tld sp, ix\n";

    os << "\tld hl, " << offset << "\n";
    os << "\tadd hl, sp\n";
    os << "\tld sp, hl\n";
  }
}

string AsmPrinter::get_ix(int base, int offset) {
  if (base <= 0) {
    return "(ix-" + to_string(abs(base) + offset) + ")";
  } else {
    return "(ix+" + to_string(base + offset) + ")";
  }
}

void AsmPrinter::load_value(const Value *value, string reg) {
  if (auto *constant = dyn_cast<ConstantInt>(value)) {
    os << "\tld " << reg << ", " << (constant->getSExtValue() & 0xff) << "\n";
  } else {
    int offset = offsets[value];

    os << "\tld " << reg[1] << ", " << get_ix(offset) << "\n";
    os << "\tld " << reg[0] << ", " << get_ix(offset, 1) << "\n";
  }
}

void AsmPrinter::store_value(const Value *value, string reg) {
  int offset = offsets[value];
  os << "\tld " << get_ix(offset) << ", " << reg[1] << "\n";
  os << "\tld " << get_ix(offset, 1) << ", " << reg[0] << "\n";
}

void AsmPrinter::print() {
  os << "\t; Generated by ZDK C Compiler\n\n";

  for (auto &function : module) {
    string name = function.getName().str();
    current_function = &function;

    os << "\t.global " << name << "\n";
    os << name << ":\n";
    generate_prologue();

    for (auto &block : function) {
      current_block = &block;
      os << blocknums[&block] << ":\n";
      for (auto &instruction : block) {
        print_instruction(&instruction);
      }
    }
  }
}

void AsmPrinter::print_instruction(const Instruction *instruction) {
  switch (instruction->getOpcode()) {
  default:
    outs() << *instruction << "\n";
    // throw runtime_error("unhandled instruction");
    cerr << "unhandled opcode: " << instruction->getOpcode() << "\n";
    break;

  // Terminator instructions :robot:
  case Instruction::Ret:
    print_return(cast<ReturnInst>(instruction));
    break;
  case Instruction::Br:
    print_br(cast<BranchInst>(instruction));
    break;

  // Binary instructions
  case Instruction::Add:
    print_add(cast<BinaryOperator>(instruction));
    break;
  case Instruction::Sub:
    print_sub(cast<BinaryOperator>(instruction));
    break;
  case Instruction::Xor:
    print_xor(cast<BinaryOperator>(instruction));
    break;

  // Memory instructions
  case Instruction::Alloca:
    break;
  case Instruction::Load:
    print_load(cast<LoadInst>(instruction));
    break;
  case Instruction::Store:
    print_store(cast<StoreInst>(instruction));
    break;
  
  // Other instructions
  case Instruction::ICmp:
    print_icmp(cast<ICmpInst>(instruction));
    break;
  }
}

void AsmPrinter::print_return(const ReturnInst *ret) {
  if (auto *value = ret->getReturnValue()) {
    load_value(value);
  }
  if (!offsets.empty()) {
    os << "\tld sp, ix\n";
    os << "\tpop ix\n";
  }
  os << "\tret\n";
}

void AsmPrinter::print_br(const BranchInst *br) {
  if (br->isConditional()) {
    load_value(br->getCondition());
    os << "\tld a, l\n";
    os << "\tand h\n";
    os << "\tjr nz, " << blocknums[br->getSuccessor(0)];
  } else {
    os << "\tjr " << blocknums[br->getSuccessor(0)];
  }
  if (blocknums[br->getSuccessor(0)] < blocknums[current_block]) {
    os << "b";
  } else {
    os << "f";
  }
  os << "\n";
}

void AsmPrinter::print_add(const BinaryOperator *add) {
  load_value(add->getOperand(0));
  load_value(add->getOperand(1), "de");
  os << "\tadd hl, de\n";
  store_value(add);
}

void AsmPrinter::print_sub(const BinaryOperator *sub) {
  load_value(sub->getOperand(0));
  load_value(sub->getOperand(1), "de");
  os << "\txor a\n";
  os << "\tsbc hl, de\n";
  store_value(sub);
}

void AsmPrinter::print_xor(const BinaryOperator *xor_) {
  load_value(xor_->getOperand(0));
  load_value(xor_->getOperand(1), "de");
  os << "\tld a, l\n";
  os << "\txor e\n";
  os << "\tld l, a\n";
  os << "\tld a, h\n";
  os << "\txor d\n";
  os << "\tld h, a\n";
  store_value(xor_);
}

void AsmPrinter::print_load(const LoadInst *load) {
  load_value(load->getPointerOperand());
  store_value(load);
}

void AsmPrinter::print_store(const StoreInst *store) {
  const Value *value = store->getValueOperand();

  if (auto *constant = dyn_cast<ConstantInt>(value)) {
    os << "\tld " << get_ix(offsets[store->getPointerOperand()]) << ", " << (constant->getSExtValue() & 0xff) << "\n";
    os << "\tld " << get_ix(offsets[store->getPointerOperand()], 1) << ", " << (constant->getSExtValue() >> 8) << "\n";
  } else {
    load_value(value);
    store_value(store->getPointerOperand());
  }
}

void AsmPrinter::print_icmp(const ICmpInst *icmp) {
  load_value(icmp->getOperand(0));
  load_value(icmp->getOperand(1), "de");
  
  // Set flags
  os << "\txor a\n";
  os << "\tsbc hl, de\n";
  // Obtain flags
  os << "\tpush af\n";
  os << "\tpop hl\n";

  switch (icmp->getPredicate()) {
  default:
    cerr << "unhandled icmp predicate: " << icmp->getPredicate() << "\n";
    break;
  case ICmpInst::ICMP_EQ:
    os << "\tld a, l\n";
    os << "\tand " << (1 << 6) << "\n";
    os << "\tld l, a\n";
    break;
  case ICmpInst::ICMP_NE:
    os << "\tld a, l\n";
    os << "\tand " << (1 << 6) << "\n";
    os << "\txor " << (1 << 6) << "\n";
    os << "\tld l, a\n";
    break;
  }

  store_value(icmp);
}
