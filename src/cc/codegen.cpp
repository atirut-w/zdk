#include <codegen.hpp>
#include <cstdint>
#include <variant>
#include <z80.hpp>

using namespace std;
using namespace ZIR;

Codegen::Codegen(std::ostream &out, const Module &module) : out(out), module(module)
{
}

void Codegen::load(const Operand &operand, uint8_t reg)
{
    string reg_name = Z80::register_names[reg];

    // TODO: Implement linear scan register allocation
    if (holds_alternative<int>(operand.value))
    {
        out << "\tld " << reg_name << ", " << get<int>(operand.value) << "\n";
    }
    else if (holds_alternative<string>(operand.value))
    {
        int offset = ctx.offsets[get<string>(operand.value)];
        out << "\tld " << reg_name[1] << ", (iy + " << offset << ")\n";
        out << "\tld " << reg_name[0] << ", (iy + " << offset + 1 << ")\n";
    }
    else
    {
        throw runtime_error("not implemented");
    }
}

void Codegen::store(uint8_t reg, const Operand &operand)
{
    // TODO: Tie this into the register allocator and make storing to memory implicit
    if (holds_alternative<string>(operand.value))
    {
        out << "\tld (iy + " << ctx.offsets[get<string>(operand.value)] << "), l\n";
        out << "\tld (iy + " << ctx.offsets[get<string>(operand.value)] + 1 << "), h\n";
    }
    else
    {
        throw runtime_error("not implemented");
    }
}

void Codegen::generate()
{
    out << "\t; Generated by ZDK C Compiler\n\n";

    for (const auto &symbol : module.symbols)
    {
        if (auto function = dynamic_cast<const Module::Function *>(symbol.get()))
        {
            generate_function(*function);
        }
    }
}

void Codegen::generate_function(const Module::Function &function)
{
    ctx = {};
    ctx.function = &function;

    int offset = 0;
    for (const auto &local : function.locals)
    {
        ctx.offsets[local->name] = offset;
        offset += 2;
    }

    out << "\t.global " << function.name << "\n";
    out << "\t.type " << function.name << ", @function\n";
    out << function.name << ":\n";

    if (function.locals.size() > 0)
    {
        out << "\tpush iy\n";
        out << "\tpush ix\n";
        out << "\tld ix , 0\n";
        out << "\tadd ix, sp\n";
        out << "\tld iy, -" << function.locals.size() * 2 << "\n";
        out << "\tadd iy, sp\n";
        out << "\tld sp, iy\n";
    }

    for (const auto &instruction : function.instructions)
    {
        generate_instruction(instruction);
    }

    if (function.instructions.back().operation != Instruction::RETURN)
    {
        generate_epilogue();
        out << "\tret\n";
    }
}

void Codegen::generate_epilogue()
{
    if (ctx.function->locals.size() > 0)
    {
        out << "\tld sp, ix\n";
        out << "\tpop ix\n";
        out << "\tpop iy\n";
    }
}

void Codegen::generate_instruction(const Instruction &instruction)
{
    switch (instruction.operation)
    {
    default:
        throw runtime_error("not implemented");
    case Instruction::RETURN:
        out << "\t; RETURN\n";

        load(instruction.operands[0], Z80::R16_HL);
        generate_epilogue();
        out << "\tret\n";
        break;
    case Instruction::UNARY:
        out << "\t; UNARY\n";

        load(instruction.operands[1], Z80::R16_HL);

        switch (get<char>(instruction.operands[0].value))
        {
        default:
            throw runtime_error("not implemented");
        case '-':
            out << "\tcall _neg16\n";
            break;
        case '~':
            out << "\tcall _not16\n";
            break;
        }

        store(Z80::R16_HL, *instruction.result);
        break;
    case Instruction::BINARY:
        out << "\t; BINARY\n";

        load(instruction.operands[1], Z80::R16_HL);
        load(instruction.operands[2], Z80::R16_DE);

        switch (get<char>(instruction.operands[0].value))
        {
        default:
            throw runtime_error("not implemented");
        case '+':
            out << "\tadd hl, de\n";
            break;
        case '-':
            out << "\txor a\n"; // No plain SUB for 16-bit registers :(
            out << "\tsbc hl, de\n";
            break;
        case '*':
            out << "\tcall _mul16\n";
            break;
        case '/':
            out << "\tcall _div16\n";
            break;
        case '%':
            out << "\tcall _mod16\n";
            break;
        }

        store(Z80::R16_HL, *instruction.result);
        break;
    }
}
