#include "analyzer.hpp"
#include "types.hpp"
#include <cctype>
#include <codegen.hpp>
#include <iostream>
#include <string>

using namespace std;
using namespace antlr4;

CodeGen::CodeGen(ProgramMeta &program_meta, std::ostream &output) : program_meta(program_meta), output(output)
{
    output << "\t; Generated by ZDK C Compiler\n\n";
}

void CodeGen::teardown_frame()
{
    // TODO: clause for arguments
    if (current_function->local_alloc > 0 || false)
    {
        output << "\tld sp, ix\n";
        output << "\tpop ix\n";
        if (current_function->local_alloc > 0)
        {
            output << "\tpop iy\n";
        }
    }
}

void CodeGen::primitive_cast(DeclarationMeta to)
{
    auto *to_primitive = dynamic_cast<PrimitiveType *>(to.type);

    if (to_primitive->size == 1)
    {
        output << "\tld a, " << current_expression->type->byte_layout[0] << "\n";
    }
    else
    {
        if (current_expression->type->size < to_primitive->size)
        {
            for (int nbytes = 0; nbytes < current_expression->type->size; nbytes++)
            {
                if (current_expression->type->byte_layout[nbytes] != to_primitive->byte_layout[nbytes])
                    output << "\tld " << to_primitive->byte_layout[nbytes] << ", "
                           << current_expression->type->byte_layout[nbytes] << "\n";
            }

            if (to.signedness)
            {
                if (current_expression->type->byte_layout[current_expression->type->size - 1] != "a")
                    output << "\tld a, " << current_expression->type->byte_layout[current_expression->type->size - 1]
                           << "\n";
                output << "\tadd a, a\n";
                output << "\tsbc a, a\n";
            }
            else
            {
                output << "\tld a, 0\n";
            }

            for (int nbytes = current_expression->type->size; nbytes < to_primitive->size; nbytes++)
            {
                output << "\tld " << to_primitive->byte_layout[nbytes] << ", a\n";
            }
        }
        else
        {
            for (int nbytes = 0; nbytes < to_primitive->size; nbytes++)
            {
                if (current_expression->type->byte_layout[nbytes] != to_primitive->byte_layout[nbytes])
                    output << "\tld " << to_primitive->byte_layout[nbytes] << ", "
                           << current_expression->type->byte_layout[nbytes] << "\n";
            }
        }
    }
}

any CodeGen::visitFunctionDefinition(CParser::FunctionDefinitionContext *ctx)
{
    string name = ctx->declarator()->directDeclarator()->directDeclarator()->Identifier()->getText();
    current_function = &program_meta.functions[name];

    output << "\t.global " << name << "\n";
    output << "\t.type " << name << ", @function\n";
    output << name << ":\n";

    // TODO: clause for arguments
    if (current_function->local_alloc > 0 || false)
    {
        if (current_function->local_alloc > 0)
        {
            output << "\tpush iy\n";
        }
        output << "\tpush ix\n";
        output << "\tld ix, 0\n";
        output << "\tadd ix, sp\n";

        if (current_function->local_alloc > 0)
        {
            output << "\tld iy, " << -current_function->local_alloc << "\n";
            output << "\tadd iy, sp\n";
            output << "\tld sp, iy\n";
        }
    }

    if (auto block_itemlist_ctx = ctx->compoundStatement()->blockItemList())
    {
        for (auto block_item_ctx : block_itemlist_ctx->blockItem())
        {
            visit(block_item_ctx);
        }
    }

    if (!current_function->has_return)
    {
        teardown_frame();
        output << "\tret\n";
    }

    return any();
}

any CodeGen::visitJumpStatement(CParser::JumpStatementContext *ctx)
{
    if (ctx->Return())
    {
        visit(ctx->expression());
        primitive_cast(current_function->return_type);
        teardown_frame();
        output << "\tret\n";
    }
    else
    {
        throw runtime_error("unsupported jump statement");
    }

    return any();
}

any CodeGen::visitInitDeclarator(CParser::InitDeclaratorContext *ctx)
{
    string name = ctx->declarator()->directDeclarator()->Identifier()->getText();
    LocalMeta &local_meta = current_function->variables[name];
    last_local = &local_meta;

    if (auto init_ctx = ctx->initializer())
    {
        if (auto assignment_ctx = init_ctx->assignmentExpression())
        {
            output << "\t; Init \"" << name << "\"\n";
            visit(assignment_ctx);
            PrimitiveType *store_type = dynamic_cast<PrimitiveType *>(local_meta.declaration.type);

            if (store_type)
            {
                primitive_cast(local_meta.declaration);
                for (int i = 0; i < store_type->size; i++)
                {
                    output << "\tld (iy+" << local_meta.offset + i << "), " << store_type->byte_layout[i] << "\n";
                }
            }
            else
            {
                throw runtime_error("non-primitive types not supported");
            }
        }
    }

    return any();
}
