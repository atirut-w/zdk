#include <cctype>
#include <codegen.hpp>
#include <iostream>
#include <string>

using namespace std;
using namespace antlr4;

ConstantValue parse_constant(string text)
{
    // Note: I'm not handling exceptions here, because I trust the ANTLR parser to not let anything weird through.
    if (isdigit(text[0]))
    {
        if (text[0] != '0' || text.size() == 1)
        {
            if (text.find('.') != string::npos)
            {
                return stof(text);
            }
            else
            {
                return stoi(text);
            }
        }
        else
        {
            char base = tolower(text[1]);
            if (base == 'x' || base == 'X')
            {
                return stoi(text, nullptr, 16);
            }
            else if (base == 'b' || base == 'B')
            {
                return stoi(text, nullptr, 2);
            }
            else
            {
                return stoi(text, nullptr, 8);
            }
        }
    }
    else if (text[0] == '\'')
    {
        // TODO: Unescape characters
        return text[1];
    }
    else
    {
        throw runtime_error("unhandled constant type");
    }
}

CodeGen::CodeGen(Module &program_meta, std::ostream &output) : program_meta(program_meta), output(output)
{
    output << "\t; Generated by ZDK C Compiler\n\n";
}

void CodeGen::teardown_frame()
{
    // TODO: clause for arguments
    if (current_function->local_alloc > 0 || false)
    {
        output << "\tld sp, ix\n";
        output << "\tpop ix\n";
        if (current_function->local_alloc > 0)
        {
            output << "\tpop iy\n";
        }
    }
}

any CodeGen::visitFunctionDefinition(CParser::FunctionDefinitionContext *ctx)
{
    string name = ctx->declarator()->directDeclarator()->directDeclarator()->Identifier()->getText();
    current_function = &program_meta.functions[name];

    output << "\t.global " << name << "\n";
    output << "\t.type " << name << ", @function\n";
    output << name << ":\n";

    // TODO: clause for arguments
    if (current_function->local_alloc > 0 || false)
    {
        if (current_function->local_alloc > 0)
        {
            output << "\tpush iy\n";
        }
        output << "\tpush ix\n";
        output << "\tld ix, 0\n";
        output << "\tadd ix, sp\n";

        if (current_function->local_alloc > 0)
        {
            output << "\tld iy, " << -current_function->local_alloc << "\n";
            output << "\tadd iy, sp\n";
            output << "\tld sp, iy\n";
        }
    }

    if (auto block_itemlist_ctx = ctx->compoundStatement()->blockItemList())
    {
        for (auto block_item_ctx : block_itemlist_ctx->blockItem())
        {
            visit(block_item_ctx);
        }
    }

    if (!current_function->has_return)
    {
        teardown_frame();
        output << "\tret\n";
    }

    return any();
}

any CodeGen::visitJumpStatement(CParser::JumpStatementContext *ctx)
{
    if (ctx->Return())
    {
        visit(ctx->expression());
        teardown_frame();
        output << "\tret\n";
    }
    else
    {
        throw runtime_error("unsupported jump statement");
    }

    return any();
}

any CodeGen::visitPrimaryExpression(CParser::PrimaryExpressionContext *ctx)
{
    ExpressionCtx expr_ctx;

    if (auto const_ctx = ctx->Constant())
    {
        expr_ctx.constant = true;
        expr_ctx.value = parse_constant(const_ctx->getText());
    }
    else
    {
        throw runtime_error("unsupported expression type");
    }

    return expr_ctx;
}
