#include "analyzer.hpp"
#include <cctype>
#include <codegen.hpp>
#include <iostream>
#include <string>

using namespace std;
using namespace antlr4;

CodeGen::CodeGen(ProgramMeta &program_meta, std::ostream &output) : program_meta(program_meta), output(output)
{
    output << "\t; Generated by ZDK C Compiler\n\n";
}

void CodeGen::teardown_frame()
{
    // TODO: clause for arguments
    if (current_function->local_alloc > 0 || false)
    {
        output << "\tld sp, ix\n";
        output << "\tpop ix\n";
        if (current_function->local_alloc > 0)
        {
            output << "\tpop iy\n";
        }
    }
}

any CodeGen::visitFunctionDefinition(CParser::FunctionDefinitionContext *ctx)
{
    string name = ctx->declarator()->directDeclarator()->directDeclarator()->Identifier()->getText();
    current_function = &program_meta.functions[name];

    output << "\t.global " << name << "\n";
    output << "\t.type " << name << ", @function\n";
    output << name << ":\n";

    // TODO: clause for arguments
    if (current_function->local_alloc > 0 || false)
    {
        if (current_function->local_alloc > 0)
        {
            output << "\tpush iy\n";
        }
        output << "\tpush ix\n";
        output << "\tld ix, 0\n";
        output << "\tadd ix, sp\n";

        if (current_function->local_alloc > 0)
        {
            output << "\tld iy, " << -current_function->local_alloc << "\n";
            output << "\tadd iy, sp\n";
            output << "\tld sp, iy\n";
        }
    }

    if (auto block_itemlist_ctx = ctx->compoundStatement()->blockItemList())
    {
        for (auto block_item_ctx : block_itemlist_ctx->blockItem())
        {
            visit(block_item_ctx);
        }
    }

    if (!current_function->has_return)
    {
        teardown_frame();
        output << "\tret\n";
    }

    return any();
}

any CodeGen::visitJumpStatement(CParser::JumpStatementContext *ctx)
{
    if (ctx->Return())
    {
        visit(ctx->expression());
        teardown_frame();
        output << "\tret\n";
    }
    else
    {
        throw runtime_error("unsupported jump statement");
    }

    return any();
}

any CodeGen::visitInitDeclarator(CParser::InitDeclaratorContext *ctx)
{
    string name = ctx->declarator()->directDeclarator()->Identifier()->getText();
    LocalMeta &local_meta = current_function->variables[name];

    if (auto init_ctx = ctx->initializer())
    {
        if (auto assignment_ctx = init_ctx->assignmentExpression())
        {
            output << "\t; Init \"" << name << "\"\n";
            ExpressionCtx expr_ctx = any_cast<ExpressionCtx>(visit(assignment_ctx));

            if (local_meta.symbol.width == 1)
            {
                if (expr_ctx.width > 1)
                {
                    output << "\tld (iy+" << local_meta.offset << "), l\n";
                }
                else
                {
                    output << "\tld (iy+" << local_meta.offset << "), a\n";
                }
            }
            else if (local_meta.symbol.width == 2)
            {
                output << "\tld (iy+" << local_meta.offset << "), l\n";
                output << "\tld (iy+" << local_meta.offset + 1 << "), h\n";
            }
            else if (local_meta.symbol.width == 4)
            {
                output << "\tld (iy+" << local_meta.offset << "), l\n";
                output << "\tld (iy+" << local_meta.offset + 1 << "), h\n";
                output << "\tld (iy+" << local_meta.offset + 2 << "), e\n";
                output << "\tld (iy+" << local_meta.offset + 3 << "), d\n";
            }
        }
    }

    return any();
}
