#include "analyzer.hpp"
#include "types.hpp"
#include <cctype>
#include <codegen.hpp>
#include <iostream>
#include <string>

using namespace std;
using namespace antlr4;

CodeGen::CodeGen(ProgramMeta &program_meta, std::ostream &output) : program_meta(program_meta), output(output)
{
    output << "\t; Generated by ZDK C Compiler\n\n";
}

void CodeGen::teardown_frame()
{
    // TODO: clause for arguments
    if (current_function->local_alloc > 0 || false)
    {
        output << "\tld sp, ix\n";
        output << "\tpop ix\n";
        if (current_function->local_alloc > 0)
        {
            output << "\tpop iy\n";
        }
    }
}

any CodeGen::visitFunctionDefinition(CParser::FunctionDefinitionContext *ctx)
{
    string name = ctx->declarator()->directDeclarator()->directDeclarator()->Identifier()->getText();
    current_function = &program_meta.functions[name];

    output << "\t.global " << name << "\n";
    output << "\t.type " << name << ", @function\n";
    output << name << ":\n";

    // TODO: clause for arguments
    if (current_function->local_alloc > 0 || false)
    {
        if (current_function->local_alloc > 0)
        {
            output << "\tpush iy\n";
        }
        output << "\tpush ix\n";
        output << "\tld ix, 0\n";
        output << "\tadd ix, sp\n";

        if (current_function->local_alloc > 0)
        {
            output << "\tld iy, " << -current_function->local_alloc << "\n";
            output << "\tadd iy, sp\n";
            output << "\tld sp, iy\n";
        }
    }

    if (auto block_itemlist_ctx = ctx->compoundStatement()->blockItemList())
    {
        for (auto block_item_ctx : block_itemlist_ctx->blockItem())
        {
            visit(block_item_ctx);
        }
    }

    if (!current_function->has_return)
    {
        teardown_frame();
        output << "\tret\n";
    }

    return any();
}

any CodeGen::visitJumpStatement(CParser::JumpStatementContext *ctx)
{
    if (ctx->Return())
    {
        visit(ctx->expression());
        teardown_frame();
        output << "\tret\n";
    }
    else
    {
        throw runtime_error("unsupported jump statement");
    }

    return any();
}

any CodeGen::visitInitDeclarator(CParser::InitDeclaratorContext *ctx)
{
    string name = ctx->declarator()->directDeclarator()->Identifier()->getText();
    LocalMeta &local_meta = current_function->variables[name];

    if (auto init_ctx = ctx->initializer())
    {
        if (auto assignment_ctx = init_ctx->assignmentExpression())
        {
            output << "\t; Init \"" << name << "\"\n";
            ExpressionCtx expr_ctx = any_cast<ExpressionCtx>(visit(assignment_ctx));
            PrimitiveType *expr_type = dynamic_cast<PrimitiveType *>(expr_ctx.type);
            PrimitiveType *store_type = dynamic_cast<PrimitiveType *>(local_meta.type);

            if (store_type->size == 1)
            {
                output << "\tld (iy+" << local_meta.offset << "), " << expr_type->byte_layout[0] << "\n";
            }
            else
            {
                if (expr_type->size < store_type->size)
                {
                    // TODO: Consider emitting call to C runtime instead of inline code
                    // Transform expression layout to store layout
                    for (int nbytes = 0; nbytes < expr_type->size; nbytes++)
                    {
                        if (store_type->byte_layout[nbytes] != expr_type->byte_layout[nbytes])
                            output << "\tld " << store_type->byte_layout[nbytes] << ", "
                                   << expr_type->byte_layout[nbytes] << "\n";
                    }

                    if (expr_ctx.signedness)
                    {
                        if (expr_type->byte_layout[expr_type->size - 1] != "a")
                            output << "\tld a, " << expr_type->byte_layout[expr_type->size - 1] << "\n";
                        output << "\tadd a, a\n";
                        output << "\tsbc a, a\n";
                    }
                    else
                    {
                        output << "\tld a, 0\n";
                    }

                    for (int nbytes = expr_type->size; nbytes < store_type->size; nbytes++)
                    {
                        output << "\tld " << store_type->byte_layout[nbytes] << ", a\n";
                    }
                }

                for (int nbytes = 0; nbytes < store_type->size; nbytes++)
                {
                    output << "\tld (iy+" << local_meta.offset + nbytes << "), " << store_type->byte_layout[nbytes]
                           << "\n";
                }
            }
        }
    }

    return any();
}
