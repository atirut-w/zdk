#include "codegen.hpp"
#include "CParser.h"
#include <any>

using namespace std;
using namespace antlr4;

std::any Codegen::visitTranslationUnit(CParser::TranslationUnitContext *ctx) {
  os << "\t; Generated by ZDK C Compiler from "
     << ctx->start->getInputStream()->getSourceName() << "\n\n";
  this->ctx = {};

  return visitChildren(ctx);
}

std::any
Codegen::visitFunctionDefinition(CParser::FunctionDefinitionContext *ctx) {
  string name =
      dynamic_cast<CParser::FunctionDeclaratorContext *>(ctx->declarator())
          ->Identifier()
          ->getText();
  os << "\t.global " << name << "\n";
  os << "\t.type " << name << ", @function\n";
  os << name << ":\n";

  visitChildren(ctx);
  os << "\n";
  return {};
}

std::any Codegen::visitReturnStatement(CParser::ReturnStatementContext *ctx) {
  if (ctx->expression()) {
    visit(ctx->expression());
  }
  os << "\tret\n";

  return {};
}

std::any Codegen::visitIntegerConstantExpression(
    CParser::IntegerConstantExpressionContext *ctx) {
  os << "\tld hl, " << ctx->IntegerConstant()->getText() << "\n";
  return {};
}

std::any
Codegen::visitNegationExpression(CParser::NegationExpressionContext *ctx) {
  visit(ctx->expression());
  os << "\txor a\n";
  os << "\tsub l\n";
  os << "\tld l, a\n";
  os << "\tsbc a, a\n";
  os << "\tsub h\n";
  os << "\tld h, a\n";

  return {};
}

std::any
Codegen::visitBitwiseNotExpression(CParser::BitwiseNotExpressionContext *ctx) {
  visit(ctx->expression());
  os << "\tld a, h\n";
  os << "\tcpl\n";
  os << "\tld h, a\n";
  os << "\tld a, l\n";
  os << "\tcpl\n";
  os << "\tld l, a\n";

  return {};
}

std::any Codegen::visitMultiplicativeExpression(
    CParser::MultiplicativeExpressionContext *ctx) {
  visit(ctx->expression(1));
  os << "\tpush hl\n";
  os << "\tpop de\n";
  visit(ctx->expression(0));

  if (ctx->Multiply()) {
    os << "\tcall __mulsi3\n";
  } else if (ctx->Divide()) {
    os << "\tcall __divsi3\n";
  } else if (ctx->Modulo()) {
    os << "\tcall __modsi3\n";
  }

  return {};
}

std::any
Codegen::visitAdditiveExpression(CParser::AdditiveExpressionContext *ctx) {
  visit(ctx->expression(1));
  os << "\tpush hl\n";
  os << "\tpop de\n";

  if (ctx->Plus()) {
    visit(ctx->expression(0));
    os << "\tadd hl, de\n";
  } else if (ctx->Minus()) {
    visit(ctx->expression(0));
    os << "\txor a\n";
    os << "\tsbc hl, de\n";
  }

  return {};
}

std::any
Codegen::visitLogicalAndExpression(CParser::LogicalAndExpressionContext *ctx) {
  int skip = reserve_label();

  visit(ctx->expression(0));
  os << "\tld a, h\n";
  os << "\tor l\n";
  os << "\tjr z, " << forward_label(skip) << "\n";
  visit(ctx->expression(1));
  os << "\tld a, h\n";
  os << "\tor l\n";
  os << "\tjr z, " << forward_label(skip) << "\n";
  os << "\tld hl, 1\n";
  os << label(skip) << "\n";

  return {};
}

std::any
Codegen::visitLogicalOrExpression(CParser::LogicalOrExpressionContext *ctx) {
  int nz = reserve_label();
  int skip = reserve_label();
  
  visit(ctx->expression(0));
  os << "\tld a, h\n";
  os << "\tor l\n";
  os << "\tjr nz, " << forward_label(nz) << "\n";
  visit(ctx->expression(1));
  os << "\tld a, h\n";
  os << "\tor l\n";
  os << "\tjr nz, " << forward_label(nz) << "\n";
  os << "\tld hl, 0\n";
  os << "\tjr " << label(skip) << "\n";
  os << label(nz) << "\n";
  os << "\tld hl, 1\n";
  os << label(skip) << "\n";

  return {};
}
