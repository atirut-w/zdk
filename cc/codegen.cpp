#include "codegen.hpp"
#include <format>

void CodeGen::visit(cparse::TranslationUnit &tu) {
  out << "\t; Generated by zdk-cc\n";
  visit(*tu.function);
}

void CodeGen::visit(cparse::FunctionDefinition &func) {
  next_label = 0;
  current_function = &func;

  out << std::format("\t.global _{}\n", func.name);
  out << std::format("_{}:\n", func.name);

  if (!func.body->declarations.empty()) {
    // Save stack frame
    out << "\tpush ix\n";
    out << "\tld ix, 0\n";
    out << "\tadd ix, sp\n";

    int size = 0;
    int offset = 0;
    for (auto &decl : func.body->declarations) {
      size += 2; // Assume all variables are 2 bytes (int)
      offset -= 2;
      auto local = std::make_unique<LocalVariable>();
      local->name = decl->name;
      local->offset = offset;
      symbols.push_back(std::move(local));
    }

    // Allocate space on stack
    out << std::format("\tld hl, -{}\n", size);
    out << "\tadd hl, sp\n";
    out << "\tld sp, hl\n";
  }

  for (auto &stmt : func.body->statements) {
    visit(*stmt);
  }
}

void CodeGen::visit(cparse::Statement &stmt) {
  if (auto *ret = dynamic_cast<cparse::ReturnStatement *>(&stmt)) {
    visit(*ret);
  } else if (auto *expr_stmt = dynamic_cast<cparse::ExpressionStatement *>(&stmt)) {
    visit(*expr_stmt->expression);
  } else if (auto *if_stmt = dynamic_cast<cparse::IfStatement *>(&stmt)) {
    visit(*if_stmt);
  } else {
    throw std::runtime_error("Unknown statement type");
  }
}

void CodeGen::visit(cparse::ReturnStatement &ret) {
  visit(*ret.expression);
  if (!current_function->body->declarations.empty()) {
    // Restore stack frame
    out << "\tld sp, ix\n";
    out << "\tpop ix\n";
  }
  out << "\tret\n";
}

void CodeGen::visit(cparse::IfStatement &if_stmt) {
  int else_label = generate_label();
  int end_label = generate_label();

  visit(*if_stmt.condition);
  out << "\tld a, l\n";
  out << "\tor h\n";
  out << std::format("\tjp z, {}f\n", else_label);

  visit(*if_stmt.then_branch);
  out << std::format("\tjp {}f\n", end_label);

  out << std::format("{}:\n", else_label);
  if (if_stmt.else_branch) {
    visit(*if_stmt.else_branch);
  }

  out << std::format("{}:\n", end_label);
}

void CodeGen::visit(cparse::Expression &expr, bool rhs) {
  if (auto const_expr = dynamic_cast<cparse::ConstantExpression *>(&expr)) {
    visit(*const_expr, rhs);
  } else if (auto *unary_expr =
                 dynamic_cast<cparse::UnaryExpression *>(&expr)) {
    visit(*unary_expr, rhs);
  } else if (auto *be = dynamic_cast<cparse::BinaryExpression *>(&expr)) {
    visit(*be, rhs);
  } else if (auto *as = dynamic_cast<cparse::AssignmentExpression *>(&expr)) {
    visit(*as, rhs);
  } else if (auto *id_expr = dynamic_cast<cparse::IdentifierExpression *>(&expr)) {
    visit(*id_expr, rhs);
  } else if (auto *cond_expr = dynamic_cast<cparse::ConditionalExpression *>(&expr)) {
    visit(*cond_expr, rhs);
  } else {
    throw std::runtime_error("Unknown expression type");
  }
}

void CodeGen::visit(cparse::ConstantExpression &const_expr, bool rhs) {
  if (rhs) {
    out << std::format("\tld de, {}\n", const_expr.value);
  } else {
    out << std::format("\tld hl, {}\n", const_expr.value);
  }
}

void CodeGen::visit(cparse::UnaryExpression &unary_expr, bool rhs) {
  switch (unary_expr.op) {
  case cparse::UnaryExpression::Complement:
    visit(*unary_expr.operand);
    out << "\tld a, l\n";
    out << "\tcpl\n";
    out << "\tld l, a\n";
    out << "\tld a, h\n";
    out << "\tcpl\n";
    out << "\tld h, a\n";
    break;
  case cparse::UnaryExpression::Negate:
    visit(*unary_expr.operand, true);
    out << "\tor a\n";
    out << "\tld hl, 0\n";
    out << "\tsbc hl, de\n";
    break;
  default:
    throw std::runtime_error("Unknown unary operator");
  }

  if (rhs) {
    out << "\tld e, l\n";
    out << "\tld d, h\n";
  }
}

void CodeGen::visit(cparse::BinaryExpression &bin_expr, bool rhs) {
  // Special handling for short-circuiting operators
  if (bin_expr.op == cparse::BinaryExpression::And) {
    int false_label = generate_label();
    int end_label = generate_label();

    visit(*bin_expr.left);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp z, {}f\n", false_label);
    
    visit(*bin_expr.right);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp z, {}f\n", false_label);
    
    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);
    
    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);
    
    if (rhs) {
      out << "\tld e, l\n";
      out << "\tld d, h\n";
    }
    return;
  }
  
  if (bin_expr.op == cparse::BinaryExpression::Or) {
    int true_label = generate_label();
    int end_label = generate_label();

    visit(*bin_expr.left);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp nz, {}f\n", true_label);
    
    visit(*bin_expr.right);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp nz, {}f\n", true_label);
    
    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);
    
    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);
    
    if (rhs) {
      out << "\tld e, l\n";
      out << "\tld d, h\n";
    }
    return;
  }

  visit(*bin_expr.left);
  bool clobbers = dynamic_cast<cparse::ConstantExpression *>(
                      bin_expr.right.get()) == nullptr;
  if (clobbers) {
    out << "\tpush hl\n";
  }
  visit(*bin_expr.right, true);
  if (clobbers) {
    out << "\tpop hl\n";
  }

  switch (bin_expr.op) {
  default:
    throw std::runtime_error("Unknown binary operator");
  case cparse::BinaryExpression::Add:
    out << "\tadd hl, de\n";
    break;
  case cparse::BinaryExpression::Subtract:
    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    break;
  case cparse::BinaryExpression::Multiply:
  case cparse::BinaryExpression::Divide:
  case cparse::BinaryExpression::Modulus: {
    out << "\tpush de\n";
    out << "\tpush hl\n";

    std::string routine;
    switch (bin_expr.op) {
    case cparse::BinaryExpression::Multiply:
      routine = "__mulsi3";
      break;
    case cparse::BinaryExpression::Divide:
      routine = "__divsi3";
      break;
    case cparse::BinaryExpression::Modulus:
      routine = "__modsi3";
      break;
    }
    out << std::format("\tcall {}\n", routine);
    out << "\tpop bc\n";
    out << "\tpop bc\n";
    break;
  }
  case cparse::BinaryExpression::Equal: {
    int false_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp nz, {}f\n", false_label);
    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::NotEqual: {
    int true_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp nz, {}f\n", true_label);
    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::Less: {
    int true_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", true_label);
    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::LessEqual: {
    int true_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", true_label);
    out << std::format("\tjp z, {}f\n", true_label);
    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::Greater: {
    int false_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", false_label);
    out << std::format("\tjp z, {}f\n", false_label);
    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::GreaterEqual: {
    int false_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", false_label);
    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  }

  if (rhs) {
    out << "\tld e, l\n";
    out << "\tld d, h\n";
  }
}

void CodeGen::visit(cparse::AssignmentExpression &assign_expr, bool rhs) {
  // TODO: This whole thing can probably be "optimized" into just computing the
  // address and putting it in IY.
  if (auto *id_expr = dynamic_cast<cparse::IdentifierExpression *>(assign_expr.left.get())) {
    if (auto *symbol = find_symbol(id_expr->name)) {
      if (auto *local = dynamic_cast<LocalVariable *>(symbol)) {
        visit(*assign_expr.right);
        out << std::format("\tld {}, l\n", format_ix(local->offset));
        out << std::format("\tld {}, h\n", format_ix(local->offset + 1));

        if (rhs) {
          out << "\tld e, l\n";
          out << "\tld d, h\n";
        }
      } else {
        throw std::runtime_error("Unsupported symbol type");
      }
    } else {
      throw std::runtime_error(std::format("Undefined variable '{}'", id_expr->name));
    }
  } else {
    throw std::runtime_error("Left-hand side of assignment must be an identifier");
  }
}

void CodeGen::visit(cparse::IdentifierExpression &id_expr, bool rhs) {
  // TODO: Same with the IY stuff above.
  if (auto *symbol = find_symbol(id_expr.name)) {
    if (auto *local = dynamic_cast<LocalVariable *>(symbol)) {
      out << std::format("\tld l, {}\n", format_ix(local->offset));
      out << std::format("\tld h, {}\n", format_ix(local->offset + 1));

      if (rhs) {
        out << "\tld e, l\n";
        out << "\tld d, h\n";
      }
    } else {
      throw std::runtime_error("Unsupported symbol type");
    }
  } else {
    throw std::runtime_error(std::format("Undefined variable '{}'", id_expr.name));
  }
}

void CodeGen::visit(cparse::ConditionalExpression &cond_expr, bool rhs) {
  int else_label = generate_label();
  int end_label = generate_label();

  visit(*cond_expr.condition);
  out << "\tld a, l\n";
  out << "\tor h\n";
  out << std::format("\tjp z, {}f\n", else_label);

  visit(*cond_expr.then_expr);
  out << std::format("\tjp {}f\n", end_label);

  out << std::format("{}:\n", else_label);
  visit(*cond_expr.else_expr);

  out << std::format("{}:\n", end_label);

  if (rhs) {
    out << "\tld e, l\n";
    out << "\tld d, h\n";
  }
}
