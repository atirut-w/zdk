#include "codegen.hpp"
#include <format>

void CodeGen::visit(cparse::TranslationUnit &tu) {
  out << "\t; Generated by zdk-cc\n";
  visit(*tu.function);
}

void CodeGen::visit(cparse::FunctionDefinition &func) {
  next_label = 0;
  current_function = &func;

  out << std::format("\t.global _{}\n", func.name);
  out << std::format("_{}:\n", func.name);

  // Always establish a frame (inner blocks might allocate)
  out << "\tpush ix\n";
  out << "\tld ix, 0\n";
  out << "\tadd ix, sp\n";
  frame_local_off = 0;

  // Handle function body as a block scope
  visit(*func.body);

  // TODO: Fall-through return in void functions
}

void CodeGen::visit(cparse::Block &block) {
  enter_scope();
  allocate_block_locals(block.declarations);

  for (auto &stmt : block.statements) {
    visit(*stmt);
  }

  leave_scope();
}

void CodeGen::visit(cparse::Statement &stmt) {
  if (auto *ret = dynamic_cast<cparse::ReturnStatement *>(&stmt)) {
    visit(*ret);
  } else if (auto *expr_stmt =
                 dynamic_cast<cparse::ExpressionStatement *>(&stmt)) {
    visit(*expr_stmt->expression);
  } else if (auto *if_stmt = dynamic_cast<cparse::IfStatement *>(&stmt)) {
    visit(*if_stmt);
  } else if (auto *compound_stmt =
                 dynamic_cast<cparse::CompoundStatement *>(&stmt)) {
    visit(*compound_stmt);
  } else {
    throw std::runtime_error("Unknown statement type");
  }
}

void CodeGen::visit(cparse::ReturnStatement &ret) {
  visit(*ret.expression);
  // Always restore frame (discard any active inner-block locals)
  out << "\tld sp, ix\n";
  out << "\tpop ix\n";
  out << "\tret\n";
}

void CodeGen::visit(cparse::IfStatement &if_stmt) {
  int else_label = generate_label();
  int end_label = generate_label();

  visit(*if_stmt.condition);
  out << "\tld a, l\n";
  out << "\tor h\n";
  out << std::format("\tjp z, {}f\n", else_label);

  visit(*if_stmt.then_branch);
  out << std::format("\tjp {}f\n", end_label);

  out << std::format("{}:\n", else_label);
  if (if_stmt.else_branch) {
    visit(*if_stmt.else_branch);
  }

  out << std::format("{}:\n", end_label);
}

void CodeGen::visit(cparse::Expression &expr, bool rhs) {
  if (auto const_expr = dynamic_cast<cparse::ConstantExpression *>(&expr)) {
    visit(*const_expr, rhs);
  } else if (auto *unary_expr =
                 dynamic_cast<cparse::UnaryExpression *>(&expr)) {
    visit(*unary_expr, rhs);
  } else if (auto *be = dynamic_cast<cparse::BinaryExpression *>(&expr)) {
    visit(*be, rhs);
  } else if (auto *as = dynamic_cast<cparse::AssignmentExpression *>(&expr)) {
    visit(*as, rhs);
  } else if (auto *id_expr =
                 dynamic_cast<cparse::IdentifierExpression *>(&expr)) {
    visit(*id_expr, rhs);
  } else if (auto *cond_expr =
                 dynamic_cast<cparse::ConditionalExpression *>(&expr)) {
    visit(*cond_expr, rhs);
  } else {
    throw std::runtime_error("Unknown expression type");
  }
}

void CodeGen::visit(cparse::ConstantExpression &const_expr, bool rhs) {
  if (rhs) {
    out << std::format("\tld de, {}\n", const_expr.value);
  } else {
    out << std::format("\tld hl, {}\n", const_expr.value);
  }
}

void CodeGen::visit(cparse::UnaryExpression &unary_expr, bool rhs) {
  switch (unary_expr.op) {
  case cparse::UnaryExpression::Complement:
    visit(*unary_expr.operand);
    out << "\tld a, l\n";
    out << "\tcpl\n";
    out << "\tld l, a\n";
    out << "\tld a, h\n";
    out << "\tcpl\n";
    out << "\tld h, a\n";
    break;
  case cparse::UnaryExpression::Negate:
    visit(*unary_expr.operand, true);
    out << "\tor a\n";
    out << "\tld hl, 0\n";
    out << "\tsbc hl, de\n";
    break;
  default:
    throw std::runtime_error("Unknown unary operator");
  }

  if (rhs) {
    out << "\tld e, l\n";
    out << "\tld d, h\n";
  }
}

void CodeGen::visit(cparse::BinaryExpression &bin_expr, bool rhs) {
  // Special handling for short-circuiting operators
  if (bin_expr.op == cparse::BinaryExpression::And) {
    int false_label = generate_label();
    int end_label = generate_label();

    visit(*bin_expr.left);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp z, {}f\n", false_label);

    visit(*bin_expr.right);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp z, {}f\n", false_label);

    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);

    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);

    if (rhs) {
      out << "\tld e, l\n";
      out << "\tld d, h\n";
    }
    return;
  }

  if (bin_expr.op == cparse::BinaryExpression::Or) {
    int true_label = generate_label();
    int end_label = generate_label();

    visit(*bin_expr.left);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp nz, {}f\n", true_label);

    visit(*bin_expr.right);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp nz, {}f\n", true_label);

    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);

    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);

    if (rhs) {
      out << "\tld e, l\n";
      out << "\tld d, h\n";
    }
    return;
  }

  visit(*bin_expr.left);
  bool clobbers = dynamic_cast<cparse::ConstantExpression *>(
                      bin_expr.right.get()) == nullptr;
  if (clobbers) {
    out << "\tpush hl\n";
  }
  visit(*bin_expr.right, true);
  if (clobbers) {
    out << "\tpop hl\n";
  }

  switch (bin_expr.op) {
  default:
    throw std::runtime_error("Unknown binary operator");
  case cparse::BinaryExpression::Add:
    out << "\tadd hl, de\n";
    break;
  case cparse::BinaryExpression::Subtract:
    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    break;
  case cparse::BinaryExpression::Multiply:
  case cparse::BinaryExpression::Divide:
  case cparse::BinaryExpression::Modulus: {
    out << "\tpush de\n";
    out << "\tpush hl\n";

    std::string routine;
    switch (bin_expr.op) {
    case cparse::BinaryExpression::Multiply:
      routine = "__mulsi3";
      break;
    case cparse::BinaryExpression::Divide:
      routine = "__divsi3";
      break;
    case cparse::BinaryExpression::Modulus:
      routine = "__modsi3";
      break;
    }
    out << std::format("\tcall {}\n", routine);
    out << "\tpop bc\n";
    out << "\tpop bc\n";
    break;
  }
  case cparse::BinaryExpression::Equal: {
    int false_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp nz, {}f\n", false_label);
    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::NotEqual: {
    int true_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp nz, {}f\n", true_label);
    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::Less: {
    int true_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", true_label);
    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::LessEqual: {
    int true_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", true_label);
    out << std::format("\tjp z, {}f\n", true_label);
    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::Greater: {
    int false_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", false_label);
    out << std::format("\tjp z, {}f\n", false_label);
    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::GreaterEqual: {
    int false_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", false_label);
    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  }

  if (rhs) {
    out << "\tld e, l\n";
    out << "\tld d, h\n";
  }
}

void CodeGen::visit(cparse::AssignmentExpression &assign_expr, bool rhs) {
  // TODO: This whole thing can probably be "optimized" into just computing the
  // address and putting it in IY.
  if (auto *id_expr = dynamic_cast<cparse::IdentifierExpression *>(
          assign_expr.left.get())) {
    if (auto *symbol = find_symbol(id_expr->name)) {
      if (auto *local = dynamic_cast<LocalVariable *>(symbol)) {
        visit(*assign_expr.right);
        out << std::format("\tld {}, l\n", format_ix(local->offset));
        out << std::format("\tld {}, h\n", format_ix(local->offset + 1));

        if (rhs) {
          out << "\tld e, l\n";
          out << "\tld d, h\n";
        }
      } else {
        throw std::runtime_error("Unsupported symbol type");
      }
    } else {
      throw std::runtime_error(
          std::format("Undefined variable '{}'", id_expr->name));
    }
  } else {
    throw std::runtime_error(
        "Left-hand side of assignment must be an identifier");
  }
}

void CodeGen::visit(cparse::IdentifierExpression &id_expr, bool rhs) {
  // TODO: Same with the IY stuff above.
  if (auto *symbol = find_symbol(id_expr.name)) {
    if (auto *local = dynamic_cast<LocalVariable *>(symbol)) {
      out << std::format("\tld l, {}\n", format_ix(local->offset));
      out << std::format("\tld h, {}\n", format_ix(local->offset + 1));

      if (rhs) {
        out << "\tld e, l\n";
        out << "\tld d, h\n";
      }
    } else {
      throw std::runtime_error("Unsupported symbol type");
    }
  } else {
    throw std::runtime_error(
        std::format("Undefined variable '{}'", id_expr.name));
  }
}

void CodeGen::visit(cparse::ConditionalExpression &cond_expr, bool rhs) {
  int else_label = generate_label();
  int end_label = generate_label();

  visit(*cond_expr.condition);
  out << "\tld a, l\n";
  out << "\tor h\n";
  out << std::format("\tjp z, {}f\n", else_label);

  visit(*cond_expr.then_expr);
  out << std::format("\tjp {}f\n", end_label);

  out << std::format("{}:\n", else_label);
  visit(*cond_expr.else_expr);

  out << std::format("{}:\n", end_label);

  if (rhs) {
    out << "\tld e, l\n";
    out << "\tld d, h\n";
  }
}

// Single-pass local allocation helper functions

void CodeGen::adjust_sp(int bytes) {
  if (bytes == 0)
    return;
  // bytes > 0 means grow SP (free), bytes < 0 means allocate
  // Z80: HL = SP + bytes; SP = HL
  out << std::format("\tld hl, {}\n", bytes);
  out << "\tadd hl, sp\n";
  out << "\tld sp, hl\n";
}

void CodeGen::enter_scope() {
  scope_stack.push_back({symbols.size(), frame_local_off, 0});
}

void CodeGen::leave_scope() {
  auto sm = scope_stack.back();
  scope_stack.pop_back();

  if (sm.bytes_in_block)
    adjust_sp(+sm.bytes_in_block); // free this block's locals

  // pop symbols declared in this scope
  while (symbols.size() > sm.sym_top)
    symbols.pop_back();

  frame_local_off = sm.saved_off; // restore offset baseline
}

int CodeGen::allocate_block_locals(
    const std::vector<std::unique_ptr<cparse::Declaration>> &decls) {
  int total = 0;
  for (auto &decl : decls) {
    int sz =
        size_of_int();     // TODO: Replace with decl->type when types are added
    frame_local_off -= sz; // grow downward
    total += sz;

    auto local = std::make_unique<LocalVariable>();
    local->name = decl->name;
    local->offset = frame_local_off; // base (low byte)
    symbols.push_back(std::move(local));
  }
  if (total)
    adjust_sp(-total); // carve out this block's frame space
  scope_stack.back().bytes_in_block += total;
  
  // Generate initialization code for variables with initializers
  for (auto &decl : decls) {
    if (decl->initializer) {
      // Find the local variable we just created
      auto *symbol = find_symbol(decl->name);
      if (auto *local = dynamic_cast<LocalVariable *>(symbol)) {
        // Evaluate the initializer expression
        visit(*decl->initializer);
        // Store the result in the local variable
        out << std::format("\tld {}, l\n", format_ix(local->offset));
        out << std::format("\tld {}, h\n", format_ix(local->offset + 1));
      }
    }
  }
  
  return total;
}

void CodeGen::visit(cparse::CompoundStatement &compound) {
  visit(*compound.block);
}
