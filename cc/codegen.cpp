#include "codegen.hpp"
#include <format>

void CodeGen::visit(cparse::TranslationUnit &tu) {
  out << "\t; Generated by zdk-cc\n";
  visit(*tu.function);
}

void CodeGen::visit(cparse::FunctionDefinition &func) {
  next_label = 0;

  out << std::format("\t.global _{}\n", func.name);
  out << std::format("_{}:\n", func.name);

  for (auto &stmt : func.body) {
    visit(*stmt);
  }
}

void CodeGen::visit(cparse::Statement &stmt) {
  if (auto ret = dynamic_cast<cparse::ReturnStatement *>(&stmt)) {
    visit(*ret);
  } else if (auto expr_stmt = dynamic_cast<cparse::ExpressionStatement *>(&stmt)) {
    visit(*expr_stmt->expression);
  } else {
    throw std::runtime_error("Unknown statement type");
  }
}

void CodeGen::visit(cparse::ReturnStatement &ret) {
  visit(*ret.expression);
  out << "\tret\n";
}

void CodeGen::visit(cparse::Expression &expr, bool rhs) {
  if (auto const_expr = dynamic_cast<cparse::ConstantExpression *>(&expr)) {
    visit(*const_expr, rhs);
  } else if (auto *unary_expr =
                 dynamic_cast<cparse::UnaryExpression *>(&expr)) {
    visit(*unary_expr, rhs);
  } else if (auto *be = dynamic_cast<cparse::BinaryExpression *>(&expr)) {
    visit(*be, rhs);
  } else if (auto *as = dynamic_cast<cparse::AssignmentExpression *>(&expr)) {
    visit(*as, rhs);
  } else if (auto *id_expr = dynamic_cast<cparse::IdentifierExpression *>(&expr)) {
    visit(*id_expr, rhs);
  } else {
    throw std::runtime_error("Unknown expression type");
  }
}

void CodeGen::visit(cparse::ConstantExpression &const_expr, bool rhs) {
  if (rhs) {
    out << std::format("\tld de, {}\n", const_expr.value);
  } else {
    out << std::format("\tld hl, {}\n", const_expr.value);
  }
}

void CodeGen::visit(cparse::UnaryExpression &unary_expr, bool rhs) {
  switch (unary_expr.op) {
  case cparse::UnaryExpression::Complement:
    visit(*unary_expr.operand);
    out << "\tld a, l\n";
    out << "\tcpl\n";
    out << "\tld l, a\n";
    out << "\tld a, h\n";
    out << "\tcpl\n";
    out << "\tld h, a\n";
    break;
  case cparse::UnaryExpression::Negate:
    visit(*unary_expr.operand, true);
    out << "\tor a\n";
    out << "\tld hl, 0\n";
    out << "\tsbc hl, de\n";
    break;
  default:
    throw std::runtime_error("Unknown unary operator");
  }

  if (rhs) {
    out << "\tld e, l\n";
    out << "\tld d, h\n";
  }
}

void CodeGen::visit(cparse::BinaryExpression &bin_expr, bool rhs) {
  // Special handling for short-circuiting operators
  if (bin_expr.op == cparse::BinaryExpression::And) {
    int false_label = generate_label();
    int end_label = generate_label();

    visit(*bin_expr.left);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp z, {}f\n", false_label);
    
    visit(*bin_expr.right);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp z, {}f\n", false_label);
    
    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);
    
    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);
    
    if (rhs) {
      out << "\tld e, l\n";
      out << "\tld d, h\n";
    }
    return;
  }
  
  if (bin_expr.op == cparse::BinaryExpression::Or) {
    int true_label = generate_label();
    int end_label = generate_label();

    visit(*bin_expr.left);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp nz, {}f\n", true_label);
    
    visit(*bin_expr.right);
    out << "\tld a, l\n";
    out << "\tor h\n";
    out << std::format("\tjp nz, {}f\n", true_label);
    
    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);
    
    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);
    
    if (rhs) {
      out << "\tld e, l\n";
      out << "\tld d, h\n";
    }
    return;
  }

  visit(*bin_expr.left);
  bool clobbers = dynamic_cast<cparse::ConstantExpression *>(
                      bin_expr.right.get()) == nullptr;
  if (clobbers) {
    out << "\tpush hl\n";
  }
  visit(*bin_expr.right, true);
  if (clobbers) {
    out << "\tpop hl\n";
  }

  switch (bin_expr.op) {
  default:
    throw std::runtime_error("Unknown binary operator");
  case cparse::BinaryExpression::Add:
    out << "\tadd hl, de\n";
    break;
  case cparse::BinaryExpression::Subtract:
    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    break;
  case cparse::BinaryExpression::Multiply:
  case cparse::BinaryExpression::Divide:
  case cparse::BinaryExpression::Modulus: {
    out << "\tpush de\n";
    out << "\tpush hl\n";

    std::string routine;
    switch (bin_expr.op) {
    case cparse::BinaryExpression::Multiply:
      routine = "__mulsi3";
      break;
    case cparse::BinaryExpression::Divide:
      routine = "__divsi3";
      break;
    case cparse::BinaryExpression::Modulus:
      routine = "__modsi3";
      break;
    }
    out << std::format("\tcall {}\n", routine);
    out << "\tpop bc\n";
    out << "\tpop bc\n";
    break;
  }
  case cparse::BinaryExpression::Equal: {
    int false_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp nz, {}f\n", false_label);
    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::NotEqual: {
    int true_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp nz, {}f\n", true_label);
    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::Less: {
    int true_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", true_label);
    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::LessEqual: {
    int true_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", true_label);
    out << std::format("\tjp z, {}f\n", true_label);
    out << "\tld hl, 0\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", true_label);
    out << "\tld hl, 1\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::Greater: {
    int false_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", false_label);
    out << std::format("\tjp z, {}f\n", false_label);
    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  case cparse::BinaryExpression::GreaterEqual: {
    int false_label = generate_label();
    int end_label = generate_label();

    out << "\tor a\n";
    out << "\tsbc hl, de\n";
    out << std::format("\tjp m, {}f\n", false_label);
    out << "\tld hl, 1\n";
    out << std::format("\tjp {}f\n", end_label);
    out << std::format("{}:\n", false_label);
    out << "\tld hl, 0\n";
    out << std::format("{}:\n", end_label);
    break;
  }
  }

  if (rhs) {
    out << "\tld e, l\n";
    out << "\tld d, h\n";
  }
}

void CodeGen::visit(cparse::AssignmentExpression &assign_expr, bool rhs) {
  if (auto *id_expr = dynamic_cast<cparse::IdentifierExpression *>(assign_expr.left.get())) {
    // TODO: Index into stack frame for local variables
    visit(*assign_expr.right);
  } else {
    throw std::runtime_error("Left-hand side of assignment must be an identifier");
  }
}

void CodeGen::visit(cparse::IdentifierExpression &id_expr, bool rhs) {
  // TODO: Index into stack frame for local variables
}
